import {
  consola
} from "./chunk-GG3ECNOI.js";

// src/index.ts
import { join } from "node:path";

// ../../node_modules/.pnpm/chalk@5.4.1/node_modules/chalk/source/vendor/ansi-styles/index.js
var ANSI_BACKGROUND_OFFSET = 10;
var wrapAnsi16 = (offset = 0) => (code) => `\x1B[${code + offset}m`;
var wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
var wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
var styles = {
  modifier: {
    reset: [0, 0],
    // 21 isn't widely supported and 22 does the same thing
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    // Bright color
    blackBright: [90, 39],
    gray: [90, 39],
    // Alias of `blackBright`
    grey: [90, 39],
    // Alias of `blackBright`
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    // Bright color
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    // Alias of `bgBlackBright`
    bgGrey: [100, 49],
    // Alias of `bgBlackBright`
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
};
var modifierNames = Object.keys(styles.modifier);
var foregroundColorNames = Object.keys(styles.color);
var backgroundColorNames = Object.keys(styles.bgColor);
var colorNames = [...foregroundColorNames, ...backgroundColorNames];
function assembleStyles() {
  const codes = /* @__PURE__ */ new Map();
  for (const [groupName, group] of Object.entries(styles)) {
    for (const [styleName, style] of Object.entries(group)) {
      styles[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`
      };
      group[styleName] = styles[styleName];
      codes.set(style[0], style[1]);
    }
    Object.defineProperty(styles, groupName, {
      value: group,
      enumerable: false
    });
  }
  Object.defineProperty(styles, "codes", {
    value: codes,
    enumerable: false
  });
  styles.color.close = "\x1B[39m";
  styles.bgColor.close = "\x1B[49m";
  styles.color.ansi = wrapAnsi16();
  styles.color.ansi256 = wrapAnsi256();
  styles.color.ansi16m = wrapAnsi16m();
  styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
  Object.defineProperties(styles, {
    rgbToAnsi256: {
      value(red, green, blue) {
        if (red === green && green === blue) {
          if (red < 8) {
            return 16;
          }
          if (red > 248) {
            return 231;
          }
          return Math.round((red - 8) / 247 * 24) + 232;
        }
        return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
      },
      enumerable: false
    },
    hexToRgb: {
      value(hex) {
        const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches) {
          return [0, 0, 0];
        }
        let [colorString] = matches;
        if (colorString.length === 3) {
          colorString = [...colorString].map((character) => character + character).join("");
        }
        const integer = Number.parseInt(colorString, 16);
        return [
          /* eslint-disable no-bitwise */
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
          /* eslint-enable no-bitwise */
        ];
      },
      enumerable: false
    },
    hexToAnsi256: {
      value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
      enumerable: false
    },
    ansi256ToAnsi: {
      value(code) {
        if (code < 8) {
          return 30 + code;
        }
        if (code < 16) {
          return 90 + (code - 8);
        }
        let red;
        let green;
        let blue;
        if (code >= 232) {
          red = ((code - 232) * 10 + 8) / 255;
          green = red;
          blue = red;
        } else {
          code -= 16;
          const remainder = code % 36;
          red = Math.floor(code / 36) / 5;
          green = Math.floor(remainder / 6) / 5;
          blue = remainder % 6 / 5;
        }
        const value = Math.max(red, green, blue) * 2;
        if (value === 0) {
          return 30;
        }
        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
        if (value === 2) {
          result += 60;
        }
        return result;
      },
      enumerable: false
    },
    rgbToAnsi: {
      value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
      enumerable: false
    },
    hexToAnsi: {
      value: (hex) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
      enumerable: false
    }
  });
  return styles;
}
var ansiStyles = assembleStyles();
var ansi_styles_default = ansiStyles;

// ../../node_modules/.pnpm/chalk@5.4.1/node_modules/chalk/source/vendor/supports-color/index.js
import process2 from "node:process";
import os from "node:os";
import tty from "node:tty";
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : process2.argv) {
  const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
  const position = argv.indexOf(prefix + flag);
  const terminatorPosition = argv.indexOf("--");
  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}
var { env } = process2;
var flagForceColor;
if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
  flagForceColor = 0;
} else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
  flagForceColor = 1;
}
function envForceColor() {
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      return 1;
    }
    if (env.FORCE_COLOR === "false") {
      return 0;
    }
    return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
  }
}
function translateLevel(level) {
  if (level === 0) {
    return false;
  }
  return {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3
  };
}
function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
  const noFlagForceColor = envForceColor();
  if (noFlagForceColor !== void 0) {
    flagForceColor = noFlagForceColor;
  }
  const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
  if (forceColor === 0) {
    return 0;
  }
  if (sniffFlags) {
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
  }
  if ("TF_BUILD" in env && "AGENT_NAME" in env) {
    return 1;
  }
  if (haveStream && !streamIsTTY && forceColor === void 0) {
    return 0;
  }
  const min = forceColor || 0;
  if (env.TERM === "dumb") {
    return min;
  }
  if (process2.platform === "win32") {
    const osRelease = os.release().split(".");
    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }
    return 1;
  }
  if ("CI" in env) {
    if (["GITHUB_ACTIONS", "GITEA_ACTIONS", "CIRCLECI"].some((key) => key in env)) {
      return 3;
    }
    if (["TRAVIS", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
      return 1;
    }
    return min;
  }
  if ("TEAMCITY_VERSION" in env) {
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
  }
  if (env.COLORTERM === "truecolor") {
    return 3;
  }
  if (env.TERM === "xterm-kitty") {
    return 3;
  }
  if ("TERM_PROGRAM" in env) {
    const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (env.TERM_PROGRAM) {
      case "iTerm.app": {
        return version >= 3 ? 3 : 2;
      }
      case "Apple_Terminal": {
        return 2;
      }
    }
  }
  if (/-256(color)?$/i.test(env.TERM)) {
    return 2;
  }
  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
    return 1;
  }
  if ("COLORTERM" in env) {
    return 1;
  }
  return min;
}
function createSupportsColor(stream, options2 = {}) {
  const level = _supportsColor(stream, {
    streamIsTTY: stream && stream.isTTY,
    ...options2
  });
  return translateLevel(level);
}
var supportsColor = {
  stdout: createSupportsColor({ isTTY: tty.isatty(1) }),
  stderr: createSupportsColor({ isTTY: tty.isatty(2) })
};
var supports_color_default = supportsColor;

// ../../node_modules/.pnpm/chalk@5.4.1/node_modules/chalk/source/utilities.js
function stringReplaceAll(string, substring, replacer) {
  let index = string.indexOf(substring);
  if (index === -1) {
    return string;
  }
  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = "";
  do {
    returnValue += string.slice(endIndex, index) + substring + replacer;
    endIndex = index + substringLength;
    index = string.indexOf(substring, endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
  let endIndex = 0;
  let returnValue = "";
  do {
    const gotCR = string[index - 1] === "\r";
    returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
    endIndex = index + 1;
    index = string.indexOf("\n", endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}

// ../../node_modules/.pnpm/chalk@5.4.1/node_modules/chalk/source/index.js
var { stdout: stdoutColor, stderr: stderrColor } = supports_color_default;
var GENERATOR = Symbol("GENERATOR");
var STYLER = Symbol("STYLER");
var IS_EMPTY = Symbol("IS_EMPTY");
var levelMapping = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
];
var styles2 = /* @__PURE__ */ Object.create(null);
var applyOptions = (object, options2 = {}) => {
  if (options2.level && !(Number.isInteger(options2.level) && options2.level >= 0 && options2.level <= 3)) {
    throw new Error("The `level` option should be an integer from 0 to 3");
  }
  const colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options2.level === void 0 ? colorLevel : options2.level;
};
var chalkFactory = (options2) => {
  const chalk2 = (...strings) => strings.join(" ");
  applyOptions(chalk2, options2);
  Object.setPrototypeOf(chalk2, createChalk.prototype);
  return chalk2;
};
function createChalk(options2) {
  return chalkFactory(options2);
}
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (const [styleName, style] of Object.entries(ansi_styles_default)) {
  styles2[styleName] = {
    get() {
      const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
      Object.defineProperty(this, styleName, { value: builder });
      return builder;
    }
  };
}
styles2.visible = {
  get() {
    const builder = createBuilder(this, this[STYLER], true);
    Object.defineProperty(this, "visible", { value: builder });
    return builder;
  }
};
var getModelAnsi = (model, level, type, ...arguments_) => {
  if (model === "rgb") {
    if (level === "ansi16m") {
      return ansi_styles_default[type].ansi16m(...arguments_);
    }
    if (level === "ansi256") {
      return ansi_styles_default[type].ansi256(ansi_styles_default.rgbToAnsi256(...arguments_));
    }
    return ansi_styles_default[type].ansi(ansi_styles_default.rgbToAnsi(...arguments_));
  }
  if (model === "hex") {
    return getModelAnsi("rgb", level, type, ...ansi_styles_default.hexToRgb(...arguments_));
  }
  return ansi_styles_default[type][model](...arguments_);
};
var usedModels = ["rgb", "hex", "ansi256"];
for (const model of usedModels) {
  styles2[model] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "color", ...arguments_), ansi_styles_default.color.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
  const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
  styles2[bgModel] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "bgColor", ...arguments_), ansi_styles_default.bgColor.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
}
var proto = Object.defineProperties(() => {
}, {
  ...styles2,
  level: {
    enumerable: true,
    get() {
      return this[GENERATOR].level;
    },
    set(level) {
      this[GENERATOR].level = level;
    }
  }
});
var createStyler = (open, close, parent) => {
  let openAll;
  let closeAll;
  if (parent === void 0) {
    openAll = open;
    closeAll = close;
  } else {
    openAll = parent.openAll + open;
    closeAll = close + parent.closeAll;
  }
  return {
    open,
    close,
    openAll,
    closeAll,
    parent
  };
};
var createBuilder = (self, _styler, _isEmpty) => {
  const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
  Object.setPrototypeOf(builder, proto);
  builder[GENERATOR] = self;
  builder[STYLER] = _styler;
  builder[IS_EMPTY] = _isEmpty;
  return builder;
};
var applyStyle = (self, string) => {
  if (self.level <= 0 || !string) {
    return self[IS_EMPTY] ? "" : string;
  }
  let styler = self[STYLER];
  if (styler === void 0) {
    return string;
  }
  const { openAll, closeAll } = styler;
  if (string.includes("\x1B")) {
    while (styler !== void 0) {
      string = stringReplaceAll(string, styler.close, styler.open);
      styler = styler.parent;
    }
  }
  const lfIndex = string.indexOf("\n");
  if (lfIndex !== -1) {
    string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
  }
  return openAll + string + closeAll;
};
Object.defineProperties(createChalk.prototype, styles2);
var chalk = createChalk();
var chalkStderr = createChalk({ level: stderrColor ? stderrColor.level : 0 });
var source_default = chalk;

// src/index.ts
import fse2 from "fs-extra";

// src/debounce.ts
function debounce(func, wait) {
  let timeout = null;
  return function(...args) {
    if (timeout) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(() => {
      func(...args);
    }, wait);
  };
}

// src/utils.ts
import fse from "fs-extra";
import matter from "gray-matter";
function isIgnore(filename, ignoreFiles) {
  return ignoreFiles.some(
    (ignore) => ignore instanceof RegExp ? ignore.test(filename) : ignore === filename
  );
}
function readFile(filePath) {
  if (!fse.existsSync(filePath) || !filePath.endsWith(".md"))
    return "";
  try {
    return fse.readFileSync(filePath, "utf-8");
  } catch (e) {
    console.error(e);
    return "";
  }
}
function extractFrontmatterField(content, field, defaultValue) {
  try {
    const { data } = matter(content);
    if (data?.[field]) {
      return data[field];
    }
    const match = content.match(/^---\s*\n([\s\S]+?)\n---/);
    if (match) {
      const frontmatter = match[1];
      const fieldMatch = frontmatter.match(
        new RegExp(`^${field}:\\s*(.+)$`, "m")
      );
      if (fieldMatch) {
        return fieldMatch[1].trim();
      }
    }
  } catch (e) {
    console.error(e);
  }
  return defaultValue;
}
function extractOrderFromFileName(fileName, defaultValue) {
  const match = fileName.match(/^(\d+)-/);
  return match ? Number.parseInt(match[1], 10) : defaultValue;
}
function extractOrderFromFrontmatter(content, defaultValue) {
  const order = extractFrontmatterField(
    content,
    "order",
    defaultValue.toString()
  );
  const num = Number.parseInt(order, 10);
  return Number.isNaN(num) ? defaultValue : num;
}
function extractDateFromFrontmatter(content) {
  const nowISO = (/* @__PURE__ */ new Date()).toISOString();
  const extracted = extractFrontmatterField(content, "date", nowISO);
  const d = new Date(extracted);
  return Number.isNaN(d.getTime()) ? nowISO : d.toISOString();
}
function extractTitleFromFrontmatter(content, defaultTitle) {
  return extractFrontmatterField(content, "title", defaultTitle);
}
function extractTitleFromFileHeading(content, defaultTitle) {
  const match = content.match(/^#\s+(.+?)(?:\s+\{#.+?\})?$/m);
  return match ? match[1] : defaultTitle;
}
function sortMenusByKey(menus, key, sortMenusOrder) {
  for (const menu of menus) {
    if (menu.items) {
      menu.items = sortMenusByKey(menu.items, key, sortMenusOrder);
    }
  }
  return menus.sort((a, b) => {
    const aVal = a[key] ?? 0;
    const bVal = b[key] ?? 0;
    if (sortMenusOrder === "asc") {
      if (aVal < bVal)
        return -1;
      if (aVal > bVal)
        return 1;
      return 0;
    } else {
      if (aVal > bVal)
        return -1;
      if (aVal < bVal)
        return 1;
      return 0;
    }
  });
}
function sortMenusByDate(menus, key, sortMenusOrder) {
  for (const menu of menus) {
    if (menu.items) {
      menu.items = sortMenusByDate(menu.items, key, sortMenusOrder);
    }
  }
  return menus.sort((a, b) => {
    const aTime = new Date(a[key] ?? "").getTime();
    const bTime = new Date(b[key] ?? "").getTime();
    return sortMenusOrder === "asc" ? aTime - bTime : bTime - aTime;
  });
}

// src/index.ts
var defaultExcludeFiles = ["README.md", ".DS_Store", "package.json"];
var defaultExcludeFolders = [".vitepress", "node_modules", "dist", "public", ".turbo"];
var options = {};
var _excludeFiles = [];
var _excludeFolders = [];
function initializeOptions(opt) {
  options = {
    documentRootPath: "/",
    ignoreIndexItems: true,
    excludeFiles: [],
    excludeFolders: [],
    collapsed: true,
    useTitleFromFileHeading: false,
    useTitleFromFrontmatter: false,
    removeTitlePrefix: "",
    useSortFromTitle: false,
    useSortFromFrontmatter: false,
    useSortFromDate: false,
    sortMenusBy: "",
    sortMenusOrder: "asc",
    debugLog: false,
    ...opt
  };
  const { excludeFolders = [], excludeFiles = [] } = options;
  _excludeFolders = [...defaultExcludeFolders, ...excludeFolders];
  _excludeFiles = [...defaultExcludeFiles, ...excludeFiles];
}
function handleFrontmatter(fileContent, fileName = "") {
  const {
    useTitleFromFileHeading,
    useTitleFromFrontmatter,
    removeTitlePrefix,
    useSortFromTitle,
    useSortFromFrontmatter,
    useSortFromDate
  } = options;
  let text = fileName;
  if (useTitleFromFileHeading) {
    text = extractTitleFromFileHeading(fileContent, text);
  }
  if (useTitleFromFrontmatter) {
    text = extractTitleFromFrontmatter(fileContent, text);
  }
  if (removeTitlePrefix) {
    text = text.replace(removeTitlePrefix, "");
  }
  let order = 0;
  if (useSortFromTitle) {
    order = extractOrderFromFileName(fileName, order);
  }
  if (useSortFromFrontmatter) {
    order = extractOrderFromFrontmatter(fileContent, order);
  }
  let date = "";
  if (useSortFromDate) {
    date = extractDateFromFrontmatter(fileContent);
  }
  return { order, text, date };
}
async function sortTopLevelFolders(folders, scanStartPath) {
  const { sortMenusBy, sortMenusOrder } = options;
  if (!sortMenusBy) {
    return folders;
  }
  if (sortMenusBy === "fileName") {
    return folders.sort((a, b) => {
      return sortMenusOrder === "asc" ? a.localeCompare(b) : b.localeCompare(a);
    });
  }
  const folderInfo = folders.map((fname) => {
    const indexFilePath = join(scanStartPath, fname, "index.md");
    const fileContent = readFile(indexFilePath);
    const { order, text = fname, date } = handleFrontmatter(fileContent, fname);
    return {
      folderName: fname,
      text,
      order,
      date
    };
  });
  const sortableArray = folderInfo.map((info) => ({
    text: info.text,
    order: info.order
  }));
  let sortedResult = [];
  if (sortMenusBy === "frontmatterOrder") {
    sortedResult = sortMenusByKey(sortableArray, "order", sortMenusOrder);
  } else if (sortMenusBy === "frontmatterDate") {
    sortedResult = sortMenusByDate(sortableArray, "date", sortMenusOrder);
  }
  const sortedFolders = sortedResult.map((item) => {
    const match = folderInfo.find(
      (f) => f.text === item.text
    );
    return match?.folderName ?? "";
  });
  return sortedFolders.filter(Boolean);
}
function sortMenus(menus) {
  const { sortMenusBy, sortMenusOrder } = options;
  if (!sortMenusBy) {
    return menus;
  }
  switch (sortMenusBy) {
    case "fileName":
      return sortMenusByKey(menus, "text", sortMenusOrder);
    case "frontmatterOrder":
      return sortMenusByKey(menus, "order", sortMenusOrder);
    case "frontmatterDate":
      return sortMenusByDate(menus, "date", sortMenusOrder);
    default:
      return menus;
  }
}
async function createSidebarItems(basePath, pPath, ...cFolder) {
  const { ignoreIndexItems, collapsed } = options;
  const currentDir = join(pPath, ...cFolder);
  const rawNode = fse2.readdirSync(currentDir);
  if (ignoreIndexItems && rawNode.length === 1 && rawNode[0] === "index.md") {
    return [];
  }
  const sidebarItems = [];
  for (const node of rawNode) {
    const nodePath = join(currentDir, node);
    const stat = fse2.statSync(nodePath);
    if (stat.isDirectory()) {
      if (isIgnore(node, _excludeFolders)) {
        continue;
      }
      const children = await createSidebarItems(basePath, pPath, ...cFolder, node);
      const sortedChildren = sortMenus(children);
      if (children.length === 0) {
        continue;
      }
      const indexFile = join(nodePath, "index.md");
      const fileContent = readFile(indexFile);
      const { order, text = node } = handleFrontmatter(fileContent, node);
      sidebarItems.push({
        text,
        order,
        collapsed,
        link: sortedChildren[0]?.link ?? `/${basePath}/${[...cFolder, node].join("/")}/`,
        items: sortedChildren
      });
    } else if (stat.isFile()) {
      const ext = node.split(".").pop();
      if (ext !== "md") {
        continue;
      }
      if (isIgnore(node, _excludeFiles)) {
        continue;
      }
      const fileName = node.replace(/\.md$/, "");
      if (ignoreIndexItems && fileName === "index") {
        continue;
      }
      const fileContent = readFile(nodePath);
      const { order, text } = handleFrontmatter(fileContent, fileName);
      sidebarItems.push({
        text,
        order,
        link: `/${basePath}/${[...cFolder, fileName].join("/")}`
      });
    }
  }
  return sortMenus(sidebarItems);
}
async function createSidebarNav(scanStartPath, basePath) {
  consola.info(source_default.yellow("AutoNavSidebar plugin is loading..."));
  const { debugLog, ignoreIndexItems, collapsed } = options;
  const entries = fse2.readdirSync(scanStartPath);
  const sidebar = {};
  const navs = [];
  const folderEntries = [];
  const fileEntries = [];
  const rootSidebarItems = [];
  entries.forEach((entry) => {
    const fullPath = join(scanStartPath, entry);
    const stat = fse2.statSync(fullPath);
    if (stat.isDirectory() && !isIgnore(entry, _excludeFolders)) {
      folderEntries.push(entry);
    } else if (entry.endsWith(".md") && !isIgnore(entry, _excludeFiles) && !(ignoreIndexItems && entry === "index.md")) {
      fileEntries.push(entry);
    }
  });
  const indexFilePath = join(scanStartPath, "index.md");
  const fileContent = readFile(indexFilePath);
  const { text: rootText } = handleFrontmatter(fileContent, "\u9996\u9875");
  for (const file of fileEntries) {
    const filePath = join(scanStartPath, file);
    const fileContent2 = readFile(filePath);
    const fileName = file.replace(/\.md$/, "");
    const { text, order } = handleFrontmatter(fileContent2, fileName);
    const link = `/${basePath}${fileName === "index" ? "/" : `/${fileName}`}`;
    rootSidebarItems.push({
      text,
      order,
      link
    });
  }
  if (rootSidebarItems.length > 0) {
    sidebar[`/${basePath}/`] = {
      base: "",
      collapsed,
      items: sortMenus(rootSidebarItems)
    };
    navs.push({
      text: rootText,
      link: rootSidebarItems[0]?.link ?? "",
      activeMatch: `/${basePath}/`
    });
  }
  const sortedFolders = await sortTopLevelFolders(folderEntries, scanStartPath);
  for (const folder of sortedFolders) {
    const subItems = await createSidebarItems(basePath, scanStartPath, folder);
    const indexFilePath2 = join(scanStartPath, folder, "index.md");
    const fileContent2 = readFile(indexFilePath2);
    const { text = folder } = handleFrontmatter(fileContent2, folder);
    sidebar[`/${basePath}/${folder}/`] = {
      base: ``,
      collapsed,
      items: subItems
    };
    if (subItems.length > 0) {
      navs.push({
        text,
        link: subItems[0].link ?? "",
        activeMatch: `/${basePath}/${folder}/`
      });
    } else {
      navs.push({
        text,
        link: `/${basePath}/${folder}/`
      });
    }
  }
  consola.success(source_default.green("AutoNavSidebar plugin loaded successfully!"));
  if (debugLog) {
    consola.box(
      `${source_default.cyan("Sidebar:\n") + JSON.stringify(sidebar, null, 2)}

${source_default.cyan("Navs:\n")}${JSON.stringify(navs, null, 2)}`
    );
  }
  return { sidebar, navs };
}
function VitePressPluginAutoNavSidebar(opt = {}) {
  return {
    name: "vitepress-plugin-auto-nav-sidebar",
    configureServer({ watcher, restart }) {
      watcher.on(
        "all",
        debounce(async (event, path) => {
          if (!path.endsWith(".md"))
            return;
          if (event !== "change") {
            try {
              await restart();
            } catch (error) {
              console.error("Failed to restart server", error);
            }
          }
        }, 1500)
      );
    },
    async config(config) {
      initializeOptions(opt);
      const { documentRootPath = "/" } = opt;
      const scanStartPath = join(process.cwd(), documentRootPath);
      const basePath = documentRootPath.startsWith("/") ? documentRootPath.slice(1) : documentRootPath;
      const { sidebar, navs } = await createSidebarNav(scanStartPath, basePath);
      config.vitepress.site.themeConfig.sidebar = sidebar;
      config.vitepress.site.themeConfig.nav = navs;
      return config;
    }
  };
}
export {
  VitePressPluginAutoNavSidebar as default
};
